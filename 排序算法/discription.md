1，算法分类
十大排序算法可以分为两大类：
比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破
O(nlogn),因此也被称为非线性时间比较类排序。
非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行。

1 冒泡排序(Bubble Sort)(当数据接近正序时速度最快)
比较两个相邻的元素，如果第一个比第二个大，则交换它们两个；(所以是稳定的)

算法描述：对每一对相邻的元素做同样的工作，从开始第一队到结尾最后一对，这样在最后的元素应该会是最大的数；(每次排序结束会确定一个正确的位置)
针对所有的元素重复以上的步骤，除了最后一个；
重复步骤1~3，直到排序完成
代码实现 bubble_sort.h
平均复杂度O(n2),最坏时间复杂度O(n2),最好时间复杂度O(n),空间复杂度O(1);

2 选择排序(select_sort)(在数据规模较小的时候表现良好)
选择排序是一种简单直观的排序算法。它的工作原理首先在末排序列中找到最小的元素，存放到排序序列的起始位置，然后，再从剩余未排元素中继续寻找最小元素，然后放到已排序列的队尾。(不稳定)

算法描述：初始状态：无序区为R[1...n],  有序区为空
          第i趟排序开始时，当前有序区和无序区分别为R[1...i-1]和R[i...n]。该趟排序从当前无序区中选出最小关键字的记录R[k],将它与无序区的第1个记录R[i]交换.
          n-1趟排序后，数组有序化。
代码实现select——sort
平均复杂度O(n2),最坏时间复杂度O(n2),最好时间复杂度O(n2),空间复杂度O(1);

3 插入排序(insert_sort)
通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。(像是打斗地主摸牌)

算法描述：从第一个元素开始，该元素被认定已经被排序；
          取出下一个元素，在已经排序的序列中从后往前扫描；
          如果该元素大于新元素，将该元素移到下一位置；
          重复步骤三，直到找到已排序的元素小于或者等于新元素的位置；
          将新元素插入到该位置后；(稳定)
          重复步骤2~5；
代码实现insert_sort
平均复杂度O(n2),最坏时间复杂度O(n2),最好时间复杂度O(n),空间复杂度O(1)

4 希尔排序(shell_sort)  (不稳定)
第一个突破n2的排序算法，是简单插入的改进版，它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。

算法描述： 选择一个增量序列t1,t2,...,tk, 其中ti>tj,tk=1;
            按增量序列个数k，对序列进行k 趟排序；
            每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列，分别对各字表进行插入排序。进增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。
平均复杂度O(n1.3),最坏时间复杂度O(n2),最好时间复杂度O(n),空间复杂度O(1)

5 归并排序(merge_sort)
归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的引用
    自上而下的递归
    自下而上的迭代

算法描述     迭代：
            申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
            设定两个指针，最初位置分别为已经排序序列的初始位置；
            比较两个指针所指向的元素，选择相对小的元素放到合并空间，并移动指针到下一个位置；
            重复步骤三知道某一指针达到序列尾；
            将另一序列剩下的所有元素直接复制到合并序列尾；
            递归：
            把长度为n的输入序列分成两个长度为n/2的子序列；
            对这两个子序列分别采用归并排序；
            将两个排序好的子序列合并成一个最终的排序序列。

6  快速排序
快速排序运行的最坏情况是O(n^2), 比如说顺序数列的快排。但它的平均期望是O(nlogn)，并且隐含的常数因子很小，比复杂度稳定等于O(nlogn)的归并排序要小很多，所以，对绝大多数顺序性较弱的随机序列而言，快速排序总是优于归并排序

算法描述：
1，从数列中挑出一个元素，称为基准(pivot)；
2，重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区(partition)操作；
3，递归的(recursive)把小于基准值元素的子数列和大于基准值元素的子数列排序；

7 堆排序
堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏最好，平均时间复杂度均是
O(nlogn), 它也是不稳定排序。首先简单了解下堆结构。
算法描述：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶2的根节点。将其余末尾元素进行交换，此时末尾元素就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。
1 构造初始堆，将给定的无序序列构造成一个大顶堆
2 然后将对顶元素与末尾元素交换，使末尾元素最大，将剩下元素继续调整成大顶堆，再将顶元素与末尾元素交换，直到对顶元素是最小值。